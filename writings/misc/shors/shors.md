# Shor's Algorithm
<meta property="og:image" content="https://images.heb.com/is/image/HEBGrocery/000466634"/>

Suppose we want to factor $N$ into its prime 
factors. The inefficient classical way to do this
is a brute force approach that is exponential.
The most efficient classical algorithm for factoring
numbers is the [general number field sieve](https://en.wikipedia.org/wiki/General_number_field_sieve) that
takes sub-exponential time. Shor's Algorithm is a quantum algorithm that
can do this $\mathcal{O}\left(\left(\log N\right)^3\right)$ where 
N is the size of the integer.

## Shor's Algorithm Classical Part
Shor's algorithm is essentially a classical algorithm which 
requires a quantum approach for one step. In this section
we outline the classical approach.

For this discussion, we will make extensive use of 
Euclid's [greatest common divisor (gcd) algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm). 
This is efficient and has a logarithmic complexity. 

Suppose we want to factor $N$. Let's start with a guess $a$.
First let's compute $d = \gcd(a,N)$. If $d \neq 1$ we are done
because we guessed luckily and found a divisor $d$ of $N$. 
You can find the other one by doing $\frac{N}{d}$.

Instead assume that $d = 1$, i.e. $a$ and $N$ are coprime
integers. This means that $a$ is an element of the 
multiplicative group of integers modulo $N$, i.e. 
$a\in \left(\mathbb{Z}/N\mathbb{Z}\right)^{\times}$.

Now consider $\langle a \rangle$ the subgroup of $\left(\mathbb{Z}/N\mathbb{Z}\right)^{\times}$ generated by $a$

$$\langle a \rangle = \{a^k | a\in \left(\mathbb{Z}/N\mathbb{Z}\right)^{\times}, k \in \mathbb{Z}\}$$

This is a subgroup of the multiplicative group and so $a$ has an order
$r$ which is the smallest integer such that $a^r = 1 \mod N$.
For now suppose by magic you know what this $r$ is. This is the part that will
require a quantum algorithm to do efficiently, which we will 
discuss later.

The statement $a^r = 1 \mod N$ means that $a^r - 1$ is divisible
by $N$. Let's factorise this into $\left(a^{\frac{r}{2}} + 1\right)\left(a^{\frac{r}{2}} - 1\right)$. Note that if $r$ was
an odd number, $\frac{r}{2}$ will not be an integer so we have to 
restart with a different guess of $a$.

Does $N$ divide 
either of these factors? Suppose $N$ divides $\left(a^{\frac{r}{2}} - 1\right)$. That means $a^{\frac{r}{2}} = 1 \mod N$ which cannot be
true since $r$ was already the smallest integer such that 
$a^r = 1 \mod N$. Let's consider instead whether $N$ divides $a^{\frac{r}{2}} + 1$. More precisely, let's compute
$x = \gcd\left(a^{\frac{r}{2}} + 1, N\right)$. If $x = 1$, there
is no common divisor and this was a bad guess so we need a different 
guess for $a$. Suppose instead that $x \neq 0$, this means that $x$
divides $N$, and we have found a divisor (and the other divisor $\frac{N}{x}$) and we are done. 

Based on the above argument/proof, the (incomplete) algorithm
to factor $N$ is as follows:

1. Pick a guess $1 < a < N$.
2. Calculate $\gcd(a, N)$. If this is not 1, you are done.
3. Otherwise compute the order of $a$ in the group 
    $\left(\mathbb{Z}/N\mathbb{Z}\right)^{\times}$. Let this 
    be $r$. 
4. If $r$ is odd go back to step 1 and try a new guess.
5. Do $\gcd\left(a^{\frac{r}{2}} + 1, N\right)$. If this
    is 1, try a new guess. If this is not one, you are done 
    and the other divisor is $\frac{N}{\gcd\left(a^{\frac{r}{2}} + 1, N\right)}$

## Order Finding

The quantum speedup in Shor's Algorithm comes from applying quantum 
methods to find the order of $a$ in step 3. Let the order (or period) be called $r$. The basic strategy to find $r$ is to 
first apply an algorithm called quantum phase estimation with 
the unitary operator $U$ which represents multiplication by $a$ 
modulo $N$. When applied to the eigenvectors of $U$, phase estimation
will return the eigenvalues which encode the value of $r$. After 
sampling the output of the phase estimation, we use the continued
fractions algorithm to get the value of $r$ from the values sampled
from the output of the algorithm. 

## Quantum Preliminaries
Before expanding on the quantum order finding algorithm, we set out 
some preliminaries on quantum information. This introduction is intended for someone who might not necessarily have an exposure to quantum mechanics, but has an adequate linear algebra background. 
We go over the bare minimum of the mathematical axioms required to
explain the implementation of Shor's algorithm. Those comfortable with
braket notation can skip this section. Those looking for a more in
depth introduction can check out Nielsen and Chuang. 

#### Qubits
The fundamental unit of
quantum information is the qubit. A classical bit can be 
either 0 or 1. A qubit is a quantum system with which can occupy
two quantum states, which we label $\ket{0}$ and $\ket{1}$. Qubits can be realised in a variety of physical systems from electrons in atomic
energy orbitals to micrometer scale electromagnetic circuits made out
of superconductors. The question of how to engineer high quality qubits
is a central one in quantum computing right now but for most of this blog post, I'll assume we magically have access to perfect qubits that don't suffer from real world imperfections. We will return to this point
once we've gone over the math of Shor's algorithm. 

Unlike a bit, a qubit can be in an arbitrary superposition 
of $\ket{0}$ and $\ket{1}$, i.e. it can be in a state 

$$\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$$

Where $\alpha$ and $\beta \in \mathcal{C}$ and $\ket{0}$, $\ket{1}$ are orthonormal vectors. This is just physics
notation for vectors in a complex Hilbert space. $\ket{a}$ (called a ket) is 
equivalent to $\vec{a}$ and $\bra{a}$ (called a bra) is equivalent to $\vec{a}^{\dagger}$. The inner product $\vec{a}^{\dagger} \vec{b}$ is
denoted by $\braket{a}{b}$, which is called a bra(c)ket. Physicists prefer braket notation because 
it's kind of silly to write something like $\vec{0}^{\dagger}\vec{1}$.

While a qubit can be in a superposition of the 0 and 1 basis states,
any measurement on the qubit will only return either 0 or 1. The
probability of each result is given by the inner product:

$$\Pr(0) = \left|\braket{0}{\psi}\right|^2 = \left|\alpha^2\right|$$

$\Pr(1)$ is defined analogously. Note that this definition means
that $\abs{\alpha}^2 + \abs{\beta}^2 = 1$ and that for any quantum
state $\ket{\psi}$ we must have that $\abs{\braket{\psi}{\psi}}^2 = 1$.
This is why we require that the basis states $\ket{0}$ and $\ket{1}$ 
be orthonormal. 

Operations on qubits are represented by unitary matrices $U$, i.e. $UU^{\dagger} = I$ or equivalently $U$ preserves the 
inner product of the Hilbert space. These
are the quantum mechanical equivalent of classical logic gates. These
operators must be unitary to preserve the norm of the vectors they 
act on, which is the mathematical way of saying that information 
isn't lost by quantum operations. Some basic examples of single qubit
operators are the Pauli operators $\sigma_x$, $\sigma_y$, and $\sigma_z$: 

$$
    \sigma_x = 
    \begin{pmatrix}
    0 & 1 \\
    1 & 0 \\
    \end{pmatrix}, \ 
    \sigma_y = 
    \begin{pmatrix}
    0 & -i \\
    i & 0 \\
    \end{pmatrix},
    \sigma_z = 
    \begin{pmatrix}
    1 & 0 \\
    0 & -1 \\
    \end{pmatrix}
$$

#### Entanglement 

Classical computers require many billions and trillions of bits to
perform their operations, so it's unsurprising that quantum computers
will also require multiple qubits to talk to each other. Suppose we
have two qubits $A$ and $B$ with their corresponding Hilbert state spaces 
$\mathcal{H_A}$ and $\mathcal{H_B}$. Let the basis states be
$\ket{0_A}, \ket{1_A}$ and $\ket{0_B}, \ket{1_B}$. When these two qubits
are allowed to physically interact with each other, we say they have 
become entangled, and the state space of the combined A-B system
is given by the tensor product of Hilbert spaces $\mathcal{H} = \mathcal{H_A} \otimes \mathcal{H_B}$.
More concretely,
the basis for $\mathcal{H}$ is given by 
$$\ket{0_A 0_B}, \ket{0_A 1_B}, \ket{1_A 0_B}, \ket{1_A 1_B}$$

Often we will omit the subscripts and implicitly assume that the label
at position $n$ in the ket or bra refers to the state of qubit $n$. 

Note that it is not always possible to write a $\ket{\psi} \in \mathcal{H}$ 
as an explicit tensor product of a vector in 
$\mathcal{H_A}$ and $\mathcal{H_B}$. For example, in the case of 
two qubits, it's not hard to show that the state $\ket{00} + \ket{11}$
cannot be "factorised" into the tensor product of something in 
$\mathcal{H_A}$ and $\mathcal{H_B}$. These new states that emerge
when both qubits are entangled but can't be split back into products
of states in the individual qubit subspaces are an example of 
how quantum entanglement gives rise to new behaviour which can only be
seen when two systems interact. 

One final note is that to be able to factorise numbers, we will need 
a way to represent integers in the range $\{0, 1, ... N-1\}$ using 
qubits. The way we do this is by representing those integers by
their binary representations and mapping those onto tensor products
of qubits. For example, if you want to represent the integers from 0 to
5, you can do that with three qubits:

$$
\begin{align*}
    \ket{0} &= \ket{000} \ (0\cdot 2^2 + 0\cdot2^1 + 0\cdot2^0 = 0) \\
    \ket{1} &= \ket{001} \ (0\cdot 2^2 + 0\cdot2^1 + 1\cdot2^0 = 1) \\
    \ket{2} &= \ket{010} \ (0\cdot 2^2 + 1\cdot2^1 + 0\cdot2^0 = 2)\\
    \ket{3} &= \ket{011} \ (0\cdot 2^2 + 1\cdot2^1 + 1\cdot2^0 = 3)\\
    \ket{4} &= \ket{100} \ (1\cdot 2^2 + 0\cdot2^1 + 0\cdot2^0 = 4)\\
    \ket{5} &= \ket{101} \ (1\cdot 2^2 + 0\cdot2^1 + 1\cdot2^0 = 5) 
\end{align*}
$$

